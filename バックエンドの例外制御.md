ログ管理について

- バックエンド pino
- フロントエンド sentry

- スキーマはpublic

- テーブルは一つ: app_logs

データ構造は
id
source: バックかweb, mobileなど
level
message
meta jsonb 
created_at

metaの例
{“taskId”:123,“userId”:“alice”}


ログローテーション
Scheduled Functionで90日以上のログ削除


フロントエンドの処理フロー
エラー発生→error.tsxで捕捉→sentryに送信

バックエンドの処理フロー
エラー発生→pinoログ出力関数→自前DB保存



## バックエンドのエラー番号
不明なデータベース例外 500 
データベース処理中にエラーが発生しました

一意制約違反 409
同じデータが既に存在します

排他例外（すでに削除済み） 409
対象データはすでに削除されています

排他例外（他ユーザー更新）409
他のユーザーによって更新されています

認可エラー（不明なJWT） 401
認証トークンが無効です

### バックエンドのエラーハンドリング
```ts
export async function POST(req: Request) {
  try {
    const body = await req.json();
    // DBやバリデーションなど
    throw new DuplicateError('同じタイトルのタスクが既に存在します');
  } catch (err: any) {
    // アプリ例外ならそのまま返す
    if (err instanceof AppError) {
      logger.error({ code: err.code, message: err.message });
      return NextResponse.json(
        { errorCode: err.code, message: err.message },
        { status: err.status }
      );
    }

    // 想定外のエラー
    logger.error({ message: err.message, stack: err.stack });
    return NextResponse.json(
      { errorCode: 'INTERNAL_ERROR', message: '内部エラーが発生しました' },
      { status: 500 }
    );
  }
}
```

### フロントエンドのエラーハンドリング部分
```ts
const res = await fetch('/api/tasks', {...});
const data = await res.json();

if (!res.ok) {
  switch (data.errorCode) {
    case 'DUPLICATE_ENTRY':
      alert('同じタスクが存在します');
      break;
    case 'VERSION_CONFLICT':
      alert('他のユーザーによって更新されています');
      break;
    case 'UNAUTHORIZED_TOKEN':
      router.push('/login');
      break;
    default:
      alert('サーバーエラーが発生しました');
  }
}
```


